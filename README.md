# Lambda Gemini API (Python)

AWS Lambda function written in Python that receives a `prompt` and generates images using the Google Gemini API. The project ships with an AWS SAM infrastructure template and a GitHub Actions pipeline for automatic deployments.

## Prerequisites

- Python 3.12+
- AWS CLI configured with permissions for Lambda, API Gateway, CloudFormation, S3, and SSM Parameter Store
- SAM CLI
- Access to the Google Gemini API and an active API key

## Required variables and secrets

1. **AWS Systems Manager Parameter Store**: create a secure parameter (SecureString) that stores your Gemini API key. The Lambda reads this value at runtime using the parameter name supplied in the deployment.
   ```bash
   aws ssm put-parameter \
     --name /prod/gemini/api-key \
     --type SecureString \
     --value "YOUR_API_KEY"
   ```

2. **GitHub Secrets** for the pipeline (`Settings` > `Secrets and variables` > `Actions`):
   - `AWS_ACCESS_KEY_ID`
   - `AWS_SECRET_ACCESS_KEY`
   - `AWS_REGION` (for example `us-east-1`)
   - `SSM_PARAMETER_NAME` (for example `/prod/gemini/api-key`)

3. **Optional GitHub Variables** (`Settings` > `Secrets and variables` > `Actions` > `Variables`):
   - `AWS_STACK_NAME` (default `lambda-gemini-api`)
   - `LAMBDA_FUNCTION_NAME` (default `lambda-gemini-api`)

## Project structure

- `src/app.py`: Lambda handler that fetches the Gemini API key from SSM, calls Gemini, and returns images in base64 (defaults to the `gemini-2.5-pro` model when none is provided)
- `template.yaml`: SAM template to deploy the function and expose an HTTP endpoint
- `.github/workflows/deploy.yaml`: workflow that runs tests and deploys with SAM
- `requirements.txt`: production dependencies packaged with the function

## Running tests locally

```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements-dev.txt
pytest
```

> **Note:** This sandbox does not provide Internet access, so installing dependencies locally may fail. Run the commands above in a network-enabled environment before your first deployment.

## Manual deployment

```bash
sam build --cached --parallel
sam deploy \
  --stack-name lambda-gemini-api \
  --capabilities CAPABILITY_IAM \
  --resolve-s3 \
  --parameter-overrides \
      GoogleApiKeyParameterName=/prod/gemini/api-key \
      LambdaFunctionName=lambda-gemini-api
```

During execution the Lambda reads the parameter name from the environment variable `GOOGLE_API_KEY_PARAM`, retrieves the secret value with `WithDecryption=True`, and caches it for subsequent invocations. Ensure the execution role generated by SAM keeps the inline permissions for `ssm:GetParameter` and `kms:Decrypt` (alias `aws/ssm`) if you customise the template or use a different KMS key.

## Sample payload

```json
{
  "prompt": "A futuristic sunset landscape in digital illustration style",
  "mimeType": "image/png",
  "model": "gemini-2.5-pro"
}
```

The response returns an `images` array with objects containing `mimeType` and `data` (base64 content ready to be stored or rendered in an `<img>` via data URI).

## Pipeline flow

1. Pushing to `main` (or running the `workflow_dispatch` trigger) starts the workflow.
2. GitHub Actions installs Python 3.12, project dependencies, and runs `pytest`.
3. AWS credentials are configured through the secrets.
4. SAM builds and deploys the stack, updating or creating the Lambda function and API Gateway endpoint.

After deployment, the `ApiEndpoint` output (available in CloudFormation) exposes the URL to invoke the Lambda over HTTP.
